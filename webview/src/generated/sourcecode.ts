// Code generated by tygo. DO NOT EDIT.
import * as ts from "./typesystem"
//////////
// source: src.go
/*
This package defines source code entities - abstractions that end-user (a programmer) operates on.
For convenience these structures have json tags. This is not clean architecture but it's very handy for LSP.
*/

export interface Module {
  manifest?: Manifest;
  packages?: { [key: string]: Package};
}
export interface Manifest {
  compiler?: string; // want compiler version
  deps?: { [key: string]: Dependency}; // third-party mods (optional)
}
export interface Dependency {
  addr?: string; // e.g. "github.com/nevalang/x"
  version?: string;
}
export type Package = { [key: string]: File};
export interface File {
  imports?: { [key: string]: string};
  entities?: { [key: string]: Entity};
}
/**
 * TODO make const, type, interface and components pointers
 */
export interface Entity {
  exported?: boolean;
  kind?: EntityKind;
  const?: Const;
  type?: ts.Def;
  interface?: Interface;
  component?: Component;
}
export type EntityKind = string; // It's handy to transmit strings enum instead of digital
export const ComponentEntity: EntityKind = "component_entity";
export const ConstEntity: EntityKind = "const_entity";
export const TypeEntity: EntityKind = "type_entity";
export const InterfaceEntity: EntityKind = "interface_entity";
export interface Component {
  interface?: Interface;
  nodes?: { [key: string]: Node};
  net?: Connection[]; // Can't be map, connection side can't be map key due to selectors
}
export interface Interface {
  typeParams?: TypeParams;
  io?: IO;
  meta?: Meta;
}
export interface TypeParams {
  params?: ts.Param[];
  meta?: Meta;
}
export interface Node {
  entityRef?: EntityRef;
  typeArgs?: ts.Expr[];
  componentDi?: { [key: string]: Node};
}
export interface EntityRef {
  pkg?: string;
  name?: string;
  meta?: Meta;
}
export interface Const {
  ref?: EntityRef;
  value?: Msg;
  meta?: Meta;
}
export interface Msg {
  typeExpr?: ts.Expr;
  bool?: boolean;
  int?: number /* int */;
  float?: number /* float64 */;
  str?: string;
  vec?: Const[]; // Vecs are used for both vectors and arrays
  map?: { [key: string]: Const}; // Maps are used for both maps and structures
  meta?: Meta;
}
export interface IO {
  in?: { [key: string]: Port};
  out?: { [key: string]: Port};
}
export interface Port {
  typeExpr?: ts.Expr;
  isArray?: boolean;
}
export interface Connection {
  senderSide?: SenderConnectionSide;
  receiverSide?: ReceiverConnectionSide[];
}
export interface ReceiverConnectionSide {
  portAddr?: PortAddr;
  selectors?: string[];
}
/**
 * SenderConnectionSide unlike ReceiverConnectionSide could refer to constant.
 */
export interface SenderConnectionSide {
  portAddr?: PortAddr;
  constRef?: EntityRef;
  selectors?: string[];
}
export interface PortAddr {
  node?: string;
  port?: string;
  idx?: number /* uint8 */;
  meta?: Meta;
}
/**
 * Meta keeps info about original text related to the structured object
 */
export interface Meta {
  text?: string;
  start?: Position;
  stop?: Position;
}
export interface Position {
  line?: number /* int */;
  column?: number /* int */;
}

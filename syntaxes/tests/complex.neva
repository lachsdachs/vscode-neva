// comments

use { // asd
    std/tmp/io // asdasdas asd1 1s
    // asdasx
	stdpkg // asd
	imported/from/elsewhereas // asd
	with_alias another/imported/from/elsewhere
} // adsad

types { // adsad
    MyErr error // asdasdasd
    MyFloat float // asdasdasd
    MyBool bool // asdasdasd
    pub MyStr str // asdasdasd
    MyVec<T> []T // asdasdasd
    MyArr<T int> [512]int // asdasdasd
    MyArr<T MyVec<int>> [512]T // asdasdasd
    MyArr<T MyVec<int>> [512][]int // asdasdasd
    // 123123sa
    pub MyRec<T> { // asdasdasd
        foo int // asdasdasd
        bar str // asdasdasd
        baz MyArr<T> // asdasdasd
        bax MyArr<int> // asdasdasd
        bac MyArr<{ // asdasdasd
            bazus int // asx
            bazus2 vec<float> // asd
        }>
        bam {}
    }
    MyEnum {
        First
        Second
    }
    MyUnion MyFloat | MyVec | MyArr | MyRec | int
}

// broken example
types {
    MyErr error
    MyFloat float
    MyBool bool
    MyStr str
    MyVec<T> []T
    MyArr<T> [512]T
    MyRec<T> { 
        foo int
        bar str
        baz MyArr<T>
        baz2 MyArr<int>
        baz3 MyArr<{
            foo int
            bar str
            baz MyArr<T>
            baz2 MyArr<int>
            baz3 MyArr<int>
        }> // FIXME nested {} curly braces breakes syntax-highlighting based on {} scope
    }
    MyEnum enum {
        First
        Second
    }
    MyUnion MyFloat | MyVec<int> | MyArr<MyVec<int>> | MyRec<{foo float}> | MyEnum
}

interfaces {
    IMyInterface<T bool>(y notStorage, x int) (z T)
    pub IMyInterface2<T MyUnion>(x int) (z T)
    IMyInterface3<T bool>(y notStorage, x int) (z T)
}

const {
    myTrue true
    pi myFloat 3.14
    pub my_vec MyVec<myFloat> [pi, pi]
    zero any nil
    pub my_friend MyRec<float> {
        foo: 27
        bar: "john"
        baz: 42.0
    }
    my_str str "my string"
}

components {
    pub Doer<T float>(x int) (z T) {
        nodes {
            abstractNode IMyInterface
            printer std_pkg.Printer
            reader elsewhere.Reader<str>
        }
        net {
            in.x -> printer.in.v
            printer.out.v -> {
                reader.in.v
                out.z
            }
        }
    }

    Doer2<T float>(x int) (z T) {
        nodes {
            abstractNode IMyInterface
            printer std_pkg.Printer
            reader elsewhere.Reader<str>
        }
        net {
            in.x -> printer.in.v
            printer.out.v -> {
                reader.in.v
                out.z
            }
        }
    }
}

